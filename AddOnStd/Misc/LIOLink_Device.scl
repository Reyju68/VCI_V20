FUNCTION_BLOCK "LIOLink_Device"
TITLE = LIOLink_Device
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
AUTHOR : SIOS
FAMILY : LIOLink
VERSION : 4.0
//Acyclically reads or writes data records from and to IO-Link devices
   VAR_INPUT 
      execute : Bool;   // Request to execute function
      hwID : HW_IO;   // Hardware identifier of IO-Link master module (sub module for ET 200eco PN)
      cap : Int := 227;   // Client Access Point; 0xB400 for ET 200eco PN, CM 8x IO-Link, else 0xE003 (227)
      readWrite : Bool;   // FALSE: read, TRUE: write
      port : Int;   // Port on IO-Link master module
      index : Int;   // Address parameter index (IO-Link device); 0..32767: IOL-D; 65535: port functions
      subindex : Int;   // Address parameter subindex (IO-Link device); 0: full record; 1-255: single parameter
      writeLen : Int;   // Length of writing data (net data); 1..232
      timeout : Time := T#20S;   // Time after which the request is aborted
   END_VAR

   VAR_OUTPUT 
      done { ExternalWritable := 'False'} : Bool;   // TRUE: Commanded functionality has been completed successfully
      busy { ExternalWritable := 'False'} : Bool;   // TRUE: FB is not finished and new output values can be expected
      error { ExternalWritable := 'False'} : Bool;   // TRUE: An error occurred during the execution of the FB
      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;   // 16#0000-16#7FFF: Status of the FB, 16#8000-16#FFFF: Error identification
      diagnostics { ExternalWritable := 'False'} : "LIOLink_typeDiagnostics";   // Diagnostics information of FB
      readLen { ExternalWritable := 'False'} : Int;   // Length of read data record (number of bytes)
   END_VAR

   VAR_IN_OUT 
      record : Array[0..#UPPER_LIMIT] of Byte;   // Data area for reading/writing data (max. 232 byte)
   END_VAR

   VAR 
      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Old value of 'execute' input for edge detection
      statDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'done'
      statBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'busy'
      statError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'error'
      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;   // Static value for output 'status'
      statSubfunctionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;   // Status of WRREC/RDREC or error code from IO-Link Master (%W1: IO-Link Master error, %W0: ISDU error)
      statFBErrorState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // State in the state machine of the block where the error occurred
      statFBState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;   // State in the state machine of the FB
      statEmptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "LIOLink_typeDiagnostics";   // Empty diagnostics information (for initialization purposes only)
      instRdRec {InstructionName := 'RDREC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : RDREC;   // System function "read data record"
      instWrRec {InstructionName := 'WRREC'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : WRREC;   // System function "write data record"
      instPoll {InstructionName := 'TP_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TP_TIME;   // poll rate read data record
      instMonitor {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;   // request monitoring time
      statRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // data area for reading data
         header { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Header
            call { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Header for read/write data record
               extFunctionNum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte := 16#08;   // Extended function number (fix coded 0x08)
               port { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // variable port (user interface) 0...255
               fiIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := 16#FE4A;   // FI index (fix coded 65098)
            END_STRUCT;
            IOL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Header for IO-Link
               control { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Control byte; 0x03: read, 0x02: write
               indexHighByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // index of data record 0…32767 (high byte)
               indexLowByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // index of data record 0…32767 (low byte)
               subindex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // subindex for data record 0...255
            END_STRUCT;
         END_STRUCT;
         data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..231] of Byte;   // User data
      END_STRUCT;
      statWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // data area for writing data
         header { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Header
            call { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Header for read/write data record
               extFunctionNum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte := 16#08;   // Extended function number (fix coded 0x08)
               port { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Variable port (user interface) 0...255
               fiIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := 16#FE4A;   // FI index (fix coded 65098)
            END_STRUCT;
            IOL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Header for IO-Link
               control { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Control byte; 0x03: read, 0x02: write
               indexHighByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // index of data record 0…32767 (high byte)
               indexLowByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // index of data record 0…32767 (low byte)
               subindex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // subindex for data record 0...255
            END_STRUCT;
         END_STRUCT;
         data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..231] of Byte;   // User data
      END_STRUCT;
      statHwID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IO;   // Static value for input 'hwID'
      statCap { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Static value for input 'cap'
      statReadWrite { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stativ value for input 'readWrite'
      statTimeout { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Static value for input 'timeout'
      statLen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Length of data to be written to device
   END_VAR

   VAR_TEMP 
      tempExecute : Bool;   // Temporary value for input 'execute'
      tempIndex : DInt;   // run tag for counting loops
   END_VAR

   VAR CONSTANT 
      MODE_READ : Bool := FALSE;   // Mode to read data
      MODE_WRITE : Bool := TRUE;   // Mode to write data
      MAX_PORT : USInt := 63;   // Max. possible port
      MAX_INDEX : UInt := 32767;   // Max. possible index
      INDEX_PORT_FUNC : UInt := 65535;   // Index to address port functions
      MAX_SUBINDEX : USInt := 255;   // Max. possible subindex
      MAX_DATA : USInt := 232;   // Max. size of data to be transferred
      UPPER_LIMIT : DInt := 231;   // Upper limit of data to be transferred
      POLLING_PERIOD : Time := T#100MS;   // Time in between polls
      FB_STATE_NO_PROCESSING : DInt := 0;   // FB state: No processing
      FB_STATE_WRITE : DInt := 1;   // Write data record
      FB_STATE_POLL : DInt := 2;   // wait and poll for response
      IOL_HEADER : UInt := 65098;   // Header IO-Link
      LEN_HEADER : USInt := 8;   // Length of header
      CONTROL_WRITE : Byte := 16#02;   // Write data record
      CONTROL_READ : Byte := 16#03;   // Read data record
      STATUS_EXECUTION_FINISHED : Word := 16#0000;   // Execution finished without errors
      STATUS_NO_CALL : Word := 16#7000;   // No job being currently processed
      STATUS_FIRST_CALL : Word := 16#7001;   // First call after incoming new job (rising edge 'execute')
      STATUS_SUBSEQUENT_CALL : Word := 16#7002;   // Subsequent call during active processing without further details
      SUB_STATUS_NO_ERROR : Word := 16#0000;   // No error occured in subfunction call
      ERR_WRONG_PORT : Word := 16#8201;   // Error: wrong port
      ERR_WRONG_INDEX : Word := 16#8202;   // Error: wrong index
      ERR_WRONG_SUBINDEX : Word := 16#8203;   // Error: wrong subindex
      ERR_WRONG_LENGTH : Word := 16#8205;   // Error: wrong length for write data record
      ERR_IO_LINK : Word := 16#8401;   // Error: IO-Link master returned error code, see "diagnostics"
      ERR_INCONSISTENT_DATA : Word := 16#8402;   // Error: Read data record doesn't match request
      ERR_REQUEST_TIMEOUT : Word := 16#8403;   // Error: Request timed out
      ERR_UNDEFINED_STATE : Word := 16#8600;   // Error: due to an undefined state in state machine
      ERR_WRREC : Word := 16#8601;   // Error: WRREC encountered an error, see "diagnostics"
      ERR_RDREC : Word := 16#8602;   // Error: RDREC encountered an error, see "diagnostics"
      STATUS_MASK : DWord := 16#00FF_FF00;   // Mask to filter error codes
      STATUS_RESOURCE_BUSY : DWord := 16#0080_C200;   // Status from WRREC/RDREC: Resource is busy
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	    //===============================================================================
	    // Siemens / (c)Copyright 2020
	    //-------------------------------------------------------------------------------
	    // Title:            LIOLink_Device
	    // Function:         Acyclically reads or writes data records from and to IO-Link devices
	    // Library:          LIOLink
	    // Author:           Siemens Industry Online Support
	    // Tested with:      CPU 1513-1 PN FW 2.8
	    // Engineering:      TIA Portal V16
	    // Restrictions:     S7-1200/1500
	    // Requirements:     --
	    //-------------------------------------------------------------------------------
	    // Change log table:
	    // Version  | Date       | Expert in charge       | Changes applied
	    //----------|------------|------------------------|------------------------------
	    // 02.00.00 | 30.09.2013 | Online Support         | First release for TIA Portal V12 SP1 as IO_LINK_CALL
	    // 02.01.00 | 14.03.2014 | Online Support         | Upgrade to TIA Portal V13
	    //                                                | Upgrade of system function 'WRREC' from V1.0 to V1.1
	    // 03.00.00 | 28.02.2015 | SUP Applications       | Upgrade to TIA Portal V13 SP1
	    //                                                | Renamed FB to IO_LINK_DEVICE 
	    // 03.01.00 | 15.09.2015 | SUP Applications       | Change of #IOL_INDEX AND #Port lower boundry to 0 and improved behaviour when called in cyclic OBs with > 100 ms
	    // 04.00.00 | 01.09.2020 | Online Support         | Implemented Programming styleguide for S7-1200/1500 and PLCopen
	    //                                                | Renamed FB to LIOLink_Device 
	    //===============================================================================
	END_REGION
	
	#tempExecute := #execute; // Work with temporary value / create process image
	
	REGION TRIGGERING
	    IF (#tempExecute = TRUE) AND (#statExecuteOld = FALSE) // Check if FB is triggered
	        AND (#statStatus = #STATUS_NO_CALL)
	    THEN // First call; initialize FB
	        #statDone := FALSE;
	        #statBusy := TRUE;
	        #statError := FALSE;
	        #statStatus := #STATUS_FIRST_CALL;
	        #statSubfunctionStatus := #SUB_STATUS_NO_ERROR;
	        #statFBErrorState := 0;
	        #diagnostics := #statEmptyDiagnostics;
	        #readLen := 0;
	        
	        // Save input parameters
	        #statHwID := #hwID;
	        #statCap := INT_TO_UINT(#cap);
	        #statReadWrite := #readWrite;
	        #statTimeout := #timeout;
	        
	        // Initialize data area
	        #statRead.header."call"."port" := 16#0;
	        #statRead.header.IOL.indexLowByte := 16#0;
	        #statRead.header.IOL.indexHighByte := 16#0;
	        #statRead.header.IOL.subindex := 16#0;
	        #tempIndex := 0; // initialize loop counter      
	        FOR #tempIndex := 0 TO #UPPER_LIMIT DO
	            #statWrite.data[#tempIndex] := 16#0;
	            #statRead.data[#tempIndex] := 16#0;
	        END_FOR;
	        
	        // Check parameters
	        IF (#port < 0) OR (#port > #MAX_PORT) THEN
	            #statStatus := #ERR_WRONG_PORT;
	        ELSIF (#index < 0) OR (#index > #MAX_INDEX AND #index <> #INDEX_PORT_FUNC) THEN
	            #statStatus := #ERR_WRONG_INDEX;
	        ELSIF (#subindex < 0) OR (#subindex > #MAX_SUBINDEX) THEN
	            #statStatus := #ERR_WRONG_SUBINDEX;
	        ELSIF #statReadWrite = #MODE_WRITE AND (#writeLen < 1 OR #writeLen > #MAX_DATA) THEN
	            #statStatus := #ERR_WRONG_LENGTH;
	        END_IF;
	        
	        // setup call header
	        #statWrite.header."call"."port" := INT_TO_BYTE(#port);
	        
	        // setup IOL header 
	        #statWrite.header.IOL.indexLowByte := INT_TO_BYTE(#index);
	        #statWrite.header.IOL.indexHighByte := INT_TO_BYTE(SHR(IN := #index, N := 8));
	        #statWrite.header.IOL.subindex := INT_TO_BYTE(#subindex);
	        
	        // BODY (data max. 232 Byte, Array 0..231 of Byte) 
	        IF #statReadWrite = #MODE_WRITE THEN // Write data record requested, copy data from "record"
	            #statWrite.header.IOL.control := #CONTROL_WRITE;
	            #statLen := INT_TO_UINT(#writeLen) + #LEN_HEADER; // data length header + data = IO-Link write data record
	            // copy "record" to working area
	            FOR #tempIndex := 0 TO #writeLen - 1 DO
	                #statWrite.data[#tempIndex] := #record[#tempIndex];
	            END_FOR;
	        ELSE // Read data record requested
	            // Empty record array
	            FILL_BLK(IN := 16#0,
	                     COUNT := #MAX_DATA,
	                     OUT => #record[0]);
	            
	            #statWrite.header.IOL.control := #CONTROL_READ;
	            #statLen := #LEN_HEADER; // data length only header = IO-Link read data record
	        END_IF;
	        
	        IF #statStatus = #STATUS_FIRST_CALL THEN // Parameters OK
	            #statFBState := #FB_STATE_WRITE;  // Start sequence
	        END_IF;
	        
	    ELSIF (#statStatus = #STATUS_FIRST_CALL) THEN
	        #statStatus := #STATUS_SUBSEQUENT_CALL;
	    END_IF;
	    
	    // Edge detection 'execute' input
	    #statExecuteOld := #tempExecute;
	END_REGION TRIGGERING
	
	REGION STATE_MACHINE
	    CASE #statFBState OF
	        #FB_STATE_NO_PROCESSING:
	            REGION no processing
	                ; // No processing active
	            END_REGION no processing
	            
	        #FB_STATE_WRITE:
	            REGION write
	                // To read data records, the IO-Link master modules needs to know which port is required. Therefore it is necessary
	                // to send at first a request via write data record (header, 8 byte). As response the IO-Link master module will 
	                // send the required data record.
	                
	                #instWrRec(REQ := TRUE,
	                           ID := #statHwID,
	                           INDEX := #statCap,
	                           LEN := #statLen,
	                           RECORD := #statWrite);
	                
	                IF #instWrRec.ERROR THEN
	                    IF (#instWrRec.STATUS AND #STATUS_MASK) = #STATUS_RESOURCE_BUSY THEN
	                        #instWrRec(REQ := FALSE); // Reset requeset
	                    ELSE
	                        #statStatus := #ERR_WRREC;
	                        #statSubfunctionStatus := #instWrRec.STATUS;
	                        #statFBErrorState := #statFBState;
	                    END_IF;
	                ELSIF #instWrRec.DONE = TRUE THEN
	                    #instWrRec(REQ := FALSE); // Reset requeset
	                    
	                    #statFBState := #FB_STATE_POLL;
	                END_IF;
	            END_REGION write
	            
	        #FB_STATE_POLL: // wait and poll for response
	            REGION poll
	                #instPoll(IN := TRUE,
	                          PT := #POLLING_PERIOD);
	                
	                // read data record on falling edge
	                #instRdRec(REQ := NOT #instPoll.Q,
	                           ID := #statHwID,
	                           INDEX := #statCap,
	                           MLEN := 0, // read all data available,
	                           RECORD := #statRead);
	                
	                IF #instRdRec.ERROR = TRUE THEN
	                    IF (#instRdRec.STATUS AND #STATUS_MASK) = #STATUS_RESOURCE_BUSY THEN
	                        // Reset requests and try again
	                        #instPoll(IN := FALSE,
	                                  PT := #POLLING_PERIOD);
	                        
	                        #instRdRec(REQ := FALSE,
	                                   RECORD := #statRead);
	                    ELSE
	                        #statStatus := #ERR_RDREC;
	                        #statSubfunctionStatus := #instRdRec.STATUS;
	                        #statFBErrorState := #statFBState;
	                    END_IF;
	                ELSIF #instRdRec.VALID THEN
	                    IF // check the response wether it matches the request (compare PORT, INDEX and SUBINDEX)
	                        (#statWrite.header."call"."port" <> #statRead.header."call"."port")
	                        OR (#statWrite.header.IOL.indexHighByte <> #statRead.header.IOL.indexHighByte)
	                        OR (#statWrite.header.IOL.indexLowByte <> #statRead.header.IOL.indexLowByte)
	                        OR (#statWrite.header.IOL.subindex <> #statRead.header.IOL.subindex)
	                    THEN // read data record doesn't match the request
	                        #statStatus := #ERR_INCONSISTENT_DATA;  // output status no consistent data
	                    ELSIF #statRead.header.IOL.control = B#16#80 THEN // check the response for IO-Link errors
	                        // State 0x80 = IOL_CALL_RES PDU shows IO-Link error detect
	                        #statStatus := #ERR_IO_LINK;
	                        #statSubfunctionStatus.%B3 := #statRead.data[0]; // IO-Link master error code
	                        #statSubfunctionStatus.%B2 := #statRead.data[1]; // IO-Link master error code
	                        #statSubfunctionStatus.%B1 := #statRead.data[2]; // ISDU error code
	                        #statSubfunctionStatus.%B0 := #statRead.data[3]; // ISDU additional code
	                        #statFBErrorState := #statFBState;
	                    ELSE // read data is valid
	                        IF #statReadWrite = #MODE_READ THEN
	                            #readLen := UINT_TO_INT(#instRdRec.LEN - #LEN_HEADER);
	                            // only data will be output
	                            FOR #tempIndex := 0 TO UINT_TO_INT(#instRdRec.LEN - #LEN_HEADER - 1) DO
	                                #record[#tempIndex] := #statRead.data[#tempIndex];
	                            END_FOR;
	                        END_IF;
	                        
	                        // Reset requests
	                        #instRdRec(REQ := FALSE,
	                                   RECORD := #statRead);
	                        
	                        #instPoll(IN := FALSE,
	                                  PT := #POLLING_PERIOD);
	                        
	                        #statStatus := #STATUS_EXECUTION_FINISHED;  // request finished
	                    END_IF;
	                END_IF;
	            END_REGION poll
	            
	        ELSE // Undefined state in state machine reached
	            REGION undefined state
	                #statStatus := #ERR_UNDEFINED_STATE;
	            END_REGION undefined state no relevant case, ready for new request
	    END_CASE;
	END_REGION
	
	REGION MONITORING
	    #instMonitor(IN := #statBusy,
	                 PT := #statTimeout);
	    
	    IF #instMonitor.Q THEN
	        #statStatus := #ERR_REQUEST_TIMEOUT; // request time out
	    END_IF;
	END_REGION
	
	REGION OUTPUTS
	    // Write outputs
	    IF (#statStatus = #STATUS_EXECUTION_FINISHED) AND (#statDone = FALSE) THEN // Execution finished without errors
	        REGION execution finished
	            #statDone := TRUE;
	            #statBusy := FALSE;
	            #statError := FALSE;
	            // execution aborted --> set state no processing
	            #statFBState := #FB_STATE_NO_PROCESSING;
	        END_REGION execution finished
	        
	    ELSIF (#statStatus.%X15 = TRUE) AND (#statError = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)
	        REGION error occured
	            #statDone := FALSE;
	            #statBusy := FALSE;
	            #statError := TRUE;
	            // Write diagnostics
	            #diagnostics.status := #statStatus;
	            #diagnostics.subfunctionStatus := #statSubfunctionStatus;
	            #diagnostics.stateNumber := #statFBErrorState;
	            // Call instructions with FALSE to be ready for next job
	            #instWrRec(REQ := FALSE);
	            
	            #instRdRec(REQ := FALSE,
	                       RECORD := #statRead);
	            
	            #instPoll(IN := FALSE,
	                      PT := #POLLING_PERIOD);
	            
	            // execution aborted --> set state no processing
	            #statFBState := #FB_STATE_NO_PROCESSING;
	        END_REGION error occured
	        
	    ELSIF (#tempExecute = FALSE) AND ((#statDone = TRUE) OR (#statError = TRUE)) THEN // Reset outputs
	        REGION execute reset
	            #statDone := FALSE;
	            #statBusy := FALSE;
	            #statError := FALSE;
	            #statStatus := #STATUS_NO_CALL;
	            #readLen := 0;
	        END_REGION execute reset
	    END_IF;
	    
	    REGION write static values to outputs
	        #done := #statDone;
	        #busy := #statBusy;
	        #error := #statError;
	        #status := #statStatus;
	        ENO := NOT #statError;
	    END_REGION write static values to outputs
	END_REGION OUTPUTS
END_FUNCTION_BLOCK

